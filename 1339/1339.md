# LeetCode 1339: Maximum Product of Splitted Binary Tree

## 題目理解
給定一棵二元樹的根節點 `root`,透過移除一條邊將樹分割成兩棵子樹,使得兩棵子樹的節點總和的乘積最大化。
回傳最大乘積對 `10^9 + 7` 取餘數後的結果。

## 解題思路

### 核心概念
如果整棵樹的總和是 `total_sum`,某個子樹的總和是 `subtree_sum`,那麼:
- 另一棵子樹的總和 = `total_sum - subtree_sum`
- 乘積 = `subtree_sum × (total_sum - subtree_sum)`

### 解題步驟
1. **第一次遍歷**: 計算整棵樹的總和 (`total_sum`)
2. **第二次遍歷**: 計算每個子樹的總和,並同時計算乘積,更新最大值
3. **回傳結果**: 回傳最大乘積對 `10^9 + 7` 取餘數

## 程式架構

### 主函數: `maxProduct(self, root)`
- 計算整棵樹總和
- 初始化最大乘積為 0
- 遍歷樹找最大乘積
- 回傳結果(取餘數)

### 輔助函數1: `calculate_sum(self, node)`
**功能**: 計算以 `node` 為根的子樹總和
**遞迴邏輯**:
- 終止條件: 如果節點為空,回傳 0
- 遞迴計算: 左子樹總和 + 右子樹總和 + 當前節點值

### 輔助函數2: `find_max_product(self, node)`
**功能**: 遍歷每個子樹,計算乘積並更新最大值
**遞迴邏輯**:
- 終止條件: 如果節點為空,回傳 0
- 計算當前子樹總和
- 計算乘積並更新 `self.max_product`
- 回傳當前子樹總和(供父節點使用)

## 關鍵概念

### 1. 遞迴 (Recursion)
函數在執行過程中呼叫自己,用來處理樹狀結構。

**兩個要素**:
- **終止條件 (Base Case)**: 節點為空時回傳 0
- **遞迴呼叫**: 處理左右子樹,問題規模變小

### 2. 類別變數 (self.變數名)
使用 `self.` 讓所有函數都能存取同一個變數:
- `self.total_sum`: 整棵樹的總和
- `self.max_product`: 目前找到的最大乘積

### 3. 二元樹節點結構
- `node.val`: 節點的值
- `node.left`: 左子節點
- `node.right`: 右子節點

## 完整程式碼
```python
class Solution(object):
    def maxProduct(self, root):
        # 步驟1: 計算整棵樹的總和
        self.total_sum = self.calculate_sum(root)
        
        # 步驟2: 記錄最大乘積
        self.max_product = 0
        
        # 步驟3: 遍歷整棵樹,找最大乘積
        self.find_max_product(root)
        
        # 步驟4: 回傳結果(取餘數)
        return self.max_product % (10**9 + 7)
    
    def calculate_sum(self, node):
        # 第一步: 先檢查是否為空
        if not node:
            return 0
        
        # 第二步: 確定不是空了,才計算
        left_sum = self.calculate_sum(node.left)
        right_sum = self.calculate_sum(node.right)
        
        # 第三步: 回傳總和
        return node.val + left_sum + right_sum
    
    def find_max_product(self, node):
        # 第一步: 先檢查是否為空
        if not node:
            return 0
        
        # 第二步: 遞迴計算左右子樹
        left_sum = self.find_max_product(node.left)
        right_sum = self.find_max_product(node.right)
        
        # 第三步: 計算當前子樹的總和
        current_sum = node.val + left_sum + right_sum
        
        # 第四步: 計算乘積
        product = (self.total_sum - current_sum) * current_sum
        
        # 第五步: 更新最大值
        if product > self.max_product:
            self.max_product = product
        
        # 第六步: 回傳當前子樹總和
        return current_sum
```

## 時間與空間複雜度

- **時間複雜度**: O(n),其中 n 是節點數量(遍歷兩次)
- **空間複雜度**: O(h),其中 h 是樹的高度(遞迴呼叫堆疊)

## 重要提醒

1. **遞迴的終止條件很重要**: 必須先檢查節點是否為空
2. **self. 的使用**: 讓不同函數可以共享變數
3. **回傳值的意義**: `find_max_product` 除了更新最大值,還要回傳子樹總和供父節點使用
4. **取餘數**: 最後結果要對 `10^9 + 7` 取餘數

## 學習心得

這題學到了:
- ✅ 遞迴的概念和應用
- ✅ 如何遍歷二元樹
- ✅ 如何在遍歷過程中計算和更新資訊
- ✅ 類別變數的使用時機