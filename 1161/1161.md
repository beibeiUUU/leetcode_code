# BFS 層序遍歷 - 完整複習筆記

## 📌 問題描述

**LeetCode 1161. Maximum Level Sum of a Binary Tree**

給定一個二元樹的根節點 `root`,計算每一層節點值的總和,回傳總和最大的那一層的層數(層數從 1 開始)。

---

## 🎯 核心概念

### 什麼是 BFS(廣度優先搜尋)?

BFS 是一種**一層一層**遍歷樹的方法,就像在大樓找人時,先找完 1 樓所有房間,再找 2 樓所有房間。

**特徵:**
1. 使用**隊列(Queue)**
2. **先進先出(FIFO)**
3. **層序處理(Level by Level)**

---

## 🔧 使用的資料結構

### deque(雙向隊列)
```python
from collections import deque

queue = deque()
queue.append(1)        # 從後面加入
item = queue.popleft() # 從前面取出
len(queue)             # 隊列長度
```

**為什麼用 deque?**
- 比 `queue.Queue` 更快
- 適合演算法和 LeetCode
- 支援雙向操作

---

## 📝 演算法步驟

### 1. 初始化
```python
- 檢查樹是否為空
- 建立隊列,放入根節點
- 初始化變數:目前層數、最大總和、答案層數
```

### 2. BFS 主迴圈
```python
while 隊列不是空的:
    a. 記錄這一層有幾個節點
    b. 初始化這一層的總和為 0
    
    c. for 迴圈處理這一層的每個節點:
        - 從隊列拿出節點
        - 累加節點的值
        - 把左右小孩加進隊列(下一層)
    
    d. 比較這一層的總和是否最大
    e. 層數加 1
```

### 3. 回傳答案
```python
return 最大總和的層數
```

---

## 💻 完整程式碼
```python
from collections import deque

class Solution(object):
    def maxLevelSum(self, root):
        # 1. 檢查樹是否為空
        if not root:
            return 0
        
        # 2. 建立隊列,放入根節點
        queue = deque([root])
        
        # 3. 初始化變數
        current_level = 1           # 目前的層數
        max_sum = float('-inf')     # 最大總和(負無限大)
        max_level = 1               # 答案層數
        
        # 4. BFS 主迴圈
        while queue:
            # a. 記錄這一層的節點數
            layer_sum = 0
            layer_nodes = len(queue)
            
            # b. 處理這一層的每個節點
            for i in range(layer_nodes):
                node = queue.popleft()
                layer_sum += node.val
                
                # 把下一層的節點加進隊列
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            # c. 比較並更新最大值
            if layer_sum > max_sum:
                max_sum = layer_sum
                max_level = current_level
            
            # d. 層數加 1
            current_level += 1
        
        # 5. 回傳答案
        return max_level
```

---

## 📖 詳細例子

### Example 1

**輸入:**
```
        1              
       / \
      7   0           
     / \
    7  -8
```

**執行過程:**

#### 初始狀態
```
queue = [1]
current_level = 1
max_sum = -∞
max_level = 1
```

---

#### 第 1 輪:處理第 1 層

**開始:**
```
layer_sum = 0
layer_nodes = 1
```

**for 迴圈(跑 1 次):**
```
拿出節點: 1
layer_sum = 0 + 1 = 1
加入左小孩: 7
加入右小孩: 0
queue = [7, 0]
```

**比較:**
```
layer_sum(1) > max_sum(-∞)? 是!
max_sum = 1
max_level = 1
```

**進入下一層:**
```
current_level = 2
```

---

#### 第 2 輪:處理第 2 層

**開始:**
```
layer_sum = 0
layer_nodes = 2
```

**for 迴圈(跑 2 次):**
```
第 1 次:
  拿出節點: 7
  layer_sum = 0 + 7 = 7
  加入左小孩: 7
  加入右小孩: -8
  queue = [0, 7, -8]

第 2 次:
  拿出節點: 0
  layer_sum = 7 + 0 = 7
  0 沒有小孩
  queue = [7, -8]
```

**比較:**
```
layer_sum(7) > max_sum(1)? 是!
max_sum = 7
max_level = 2  ← 更新!
```

**進入下一層:**
```
current_level = 3
```

---

#### 第 3 輪:處理第 3 層

**開始:**
```
layer_sum = 0
layer_nodes = 2
```

**for 迴圈(跑 2 次):**
```
第 1 次:
  拿出節點: 7
  layer_sum = 0 + 7 = 7

第 2 次:
  拿出節點: -8
  layer_sum = 7 + (-8) = -1

queue = []
```

**比較:**
```
layer_sum(-1) > max_sum(7)? 否!
不更新
```

**進入下一層:**
```
current_level = 4
```

---

#### 結束
```
queue 是空的,while 迴圈結束
回傳 max_level = 2
```

**答案:第 2 層(總和 = 7)**

---

### Example 2

**輸入:**
```
        989
          \
         10250
         /
       98693
         \
        -89388
           \
          -32127
```

**層數統計:**
```
第 1 層: 989
第 2 層: 10250
第 3 層: 98693
第 4 層: -89388
第 5 層: -32127
```

**最大總和:** 第 2 層(10250)

**答案:** 2

---

## 🔑 關鍵要點

### 1. 為什麼要先記錄 `layer_nodes = len(queue)`?
```python
layer_nodes = len(queue)  # 必須先記錄!

for i in range(layer_nodes):  # 只處理這一層
    node = queue.popleft()
    queue.append(node.left)   # 加入下一層
    queue.append(node.right)  # 隊列長度改變了!
```

如果不先記錄,`len(queue)` 會在迴圈中不斷變化,就會處理到下一層的節點!

---

### 2. 為什麼 `max_sum` 初始值是 `float('-inf')`?

因為節點的值可能是**負數**!

**錯誤示範(初始值 = 0):**
```python
max_sum = 0

第 1 層總和 = -5
-5 > 0? 否,不更新

第 2 層總和 = -3
-3 > 0? 否,不更新

結果:沒有任何層被記錄!❌
```

**正確做法(初始值 = -∞):**
```python
max_sum = float('-inf')

第 1 層總和 = -5
-5 > -∞? 是,更新!✅
```

---

### 3. 為什麼要在 while 迴圈裡初始化 `layer_sum = 0`?

因為**每一層都要重新計算總和**!
```python
while queue:
    layer_sum = 0  # 每一層開始時歸零
    ...
```

如果放在 while 外面,總和會一直累加,變成「所有層的總和」!

---

## 🎓 複雜度分析

### 時間複雜度:O(n)
- n 是節點總數
- 每個節點只被訪問一次

### 空間複雜度:O(w)
- w 是樹的最大寬度(一層最多有幾個節點)
- 隊列最多存放一層的所有節點

---

## 🔄 BFS 模板(通用)
```python
from collections import deque

def bfs(root):
    if not root:
        return
    
    queue = deque([root])
    level = 1
    
    while queue:
        level_size = len(queue)
        
        # 處理這一層的每個節點
        for i in range(level_size):
            node = queue.popleft()
            
            # 在這裡處理節點
            # ...
            
            # 把下一層加進隊列
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        level += 1
```

這個模板可以用在所有需要**層序遍歷**的題目!

---

## 📚 相關題目

使用相同 BFS 技巧的題目:

1. **102. Binary Tree Level Order Traversal** - 基礎層序遍歷
2. **107. Binary Tree Level Order Traversal II** - 反向層序遍歷
3. **199. Binary Tree Right Side View** - 看樹的右側視圖
4. **515. Find Largest Value in Each Tree Row** - 找每層最大值
5. **637. Average of Levels in Binary Tree** - 計算每層平均值

---

## ✅ 複習檢查清單

- [ ] 理解 BFS 的核心概念(一層一層處理)
- [ ] 知道如何使用 `deque`
- [ ] 理解為什麼要先記錄 `len(queue)`
- [ ] 理解為什麼 `max_sum` 初始值是負無限大
- [ ] 能獨立寫出 BFS 模板
- [ ] 能用例子手動模擬執行過程

---

## 💡 常見錯誤

### 錯誤 1:不先記錄層數
```python
# ❌ 錯誤
for i in range(len(queue)):  # 長度會變化!
    node = queue.popleft()
    queue.append(node.left)
```

### 錯誤 2:layer_sum 位置錯誤
```python
# ❌ 錯誤
layer_sum = 0  # 在 while 外面

while queue:
    # layer_sum 不會歸零,會一直累加
```

### 錯誤 3:比較邏輯錯誤
```python
# ❌ 錯誤
if layer_sum > max_sum:
    layer_sum = max_sum  # 反了!
```

### 錯誤 4:忘記更新層數
```python
# ❌ 錯誤
while queue:
    ...
    # 忘記 current_level += 1
```

---

**完成日期:** 2026/01/06  
**狀態:** ✅ 通過  
**心得:** 從零開始學會 BFS、隊列、二元樹,並成功解題!

---

這份筆記包含了所有重要概念、完整例子和常見錯誤,下次複習時可以快速回顧!💪